using ArgumentParsing.Generators.CodeGen;
using ArgumentParsing.Generators.Models;
using Microsoft.CodeAnalysis;

namespace ArgumentParsing.Generators;

public partial class ArgumentParserGenerator
{
    private static void Emit(SourceProductionContext context, ArgumentParserInfo parserInfo)
    {
        (var hierarchy, var method, var optionsInfo) = parserInfo;

        var writer = new CodeWriter();

        writer.WriteLine("// <auto-generated/>");
        writer.WriteLine("#nullable disable");
        writer.WriteLine("#pragma warning disable");
        writer.WriteLine();

        var @namespace = hierarchy.Namespace;
        if (!string.IsNullOrEmpty(@namespace))
        {
            writer.WriteLine($"namespace {@namespace}");
            writer.OpenBlock();
        }

        foreach (var type in hierarchy.Hierarchy)
        {
            writer.WriteLine($"partial {type.GetTypeKeyword()} {type.QualifiedName}");
            writer.OpenBlock();
        }

        writer.WriteLine($"{method.Modifiers} {method.ReturnType} {method.Name}({method.ArgsParameterInfo.Type} {method.ArgsParameterInfo.Name})");
        writer.OpenBlock();
        writer.WriteLine("return default;"); // TODO: emit actual logic here
        writer.CloseBlock();

        writer.CloseRemainingBlocks();

        context.AddSource($"{optionsInfo.QualifiedTypeName}.g.cs", writer.ToString());
    }
}
