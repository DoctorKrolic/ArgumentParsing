using System.Diagnostics;
using ArgumentParsing.Generators.CodeGen;
using ArgumentParsing.Generators.Models;
using Microsoft.CodeAnalysis;

namespace ArgumentParsing.Generators;

public partial class ArgumentParserGenerator
{
    private const string ExcludeFromCodeCoverageAttribute = "[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverageAttribute]";

    private static void EmitArgumentParser(SourceProductionContext context, (ArgumentParserInfo, EnvironmentInfo) infos)
    {
        var (parserInfo, environmentInfo) = infos;
        var (canUseOptimalSpanBasedAlgorithm, hasStringStartsWithCharOverload) = environmentInfo;

        var cancellationToken = context.CancellationToken;

        var (hierarchy, method, optionsInfo, errorMessageFormatProvider, builtInCommandInfos, additionalCommandHandlers) = parserInfo;
        var (qualifiedName, hasAtLeastInternalAccessibility, optionInfos, parameterInfos, remainingParametersInfo, helpTextGeneratorInfo) = optionsInfo;

        var writer = new CodeWriter();

        writer.WriteLine("// <auto-generated/>");
        writer.WriteLine("#nullable disable");
        writer.WriteLine("#pragma warning disable");
        writer.WriteLine();

        var generatorType = typeof(ArgumentParserGenerator);
        var generatedCodeAttribute = $"[global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"{generatorType.FullName}\", \"{generatorType.Assembly.GetName().Version}\")]";

        var hasBuiltInHelp = builtInCommandInfos.Any(i => i.Handler == BuiltInCommandHandlers.Help);
        var hasBuiltInVersion = builtInCommandInfos.Any(i => i.Handler == BuiltInCommandHandlers.Version);
        var hasAnySpecialCommandHandlers = hasBuiltInHelp ||
            hasBuiltInVersion ||
            !additionalCommandHandlers.IsEmpty;

        if (hasAtLeastInternalAccessibility && hasBuiltInHelp || helpTextGeneratorInfo is not null)
        {
            writer.WriteLine("namespace ArgumentParsing.Generated");
            writer.OpenBlock();
            writer.WriteLine("internal static partial class ParseResultExtensions");
            writer.OpenBlock();
            writer.WriteLine("/// <summary>");
            writer.WriteLine("/// Executes common default actions for the given <see cref=\"global::ArgumentParsing.Results.ParseResult{TOptions}\"/>");
            writer.WriteLine("/// <list type=\"bullet\">");
            writer.WriteLine("/// <item>If <paramref name=\"result\"/> is in <see cref=\"global::ArgumentParsing.Results.ParseResultState.ParsedOptions\"/> state invokes provided <paramref name=\"action\"/> with parsed options object</item>");
            writer.WriteLine("/// <item>If <paramref name=\"result\"/> is in <see cref=\"global::ArgumentParsing.Results.ParseResultState.ParsedWithErrors\"/> state writes help screen text with parse errors to <see cref=\"global::System.Console.Error\"/> and exits application with code 1</item>");
            if (hasAnySpecialCommandHandlers)
            {
                writer.WriteLine("/// <item>If <paramref name=\"result\"/> is in <see cref=\"global::ArgumentParsing.Results.ParseResultState.ParsedSpecialCommand\"/> state executes parsed handler and exits application with code, returned from the handler</item>");
            }
            writer.WriteLine("/// </list>");
            writer.WriteLine("/// </summary>");
            writer.WriteLine("/// <param name=\"result\">Parse result</param>");
            writer.WriteLine("/// <param name=\"action\">Action, which will be invoked if options type is correctly parsed</param>");
            writer.WriteLine(generatedCodeAttribute);
            writer.WriteLine(ExcludeFromCodeCoverageAttribute);
            writer.WriteLine($"public static void ExecuteDefaults(this {method.ReturnType} result, global::System.Action<global::{optionsInfo.QualifiedTypeName}> action)");
            writer.OpenBlock();
            writer.WriteLine("switch (result.State)");
            writer.OpenBlock();
            writer.Ident++;
            writer.WriteLine("case global::ArgumentParsing.Results.ParseResultState.ParsedOptions:", identDelta: -1);
            writer.WriteLine("action(result.Options);");
            writer.WriteLine("break;");
            writer.WriteLine("case global::ArgumentParsing.Results.ParseResultState.ParsedWithErrors:", identDelta: -1);
            if (helpTextGeneratorInfo is null)
            {
                writer.WriteLine($"string errorScreenText = global::ArgumentParsing.Generated.HelpCommandHandler_{qualifiedName.Replace('.', '_')}.GenerateHelpText(result.Errors);");
            }
            else
            {
                writer.WriteLine($"string errorScreenText = {helpTextGeneratorInfo.TypeName}.{helpTextGeneratorInfo.MethodName}(result.Errors);");
            }
            writer.WriteLine("global::System.Console.Error.WriteLine(errorScreenText);");
            writer.WriteLine("global::System.Environment.Exit(1);");
            writer.WriteLine("break;");
            if (hasAnySpecialCommandHandlers)
            {
                writer.WriteLine("case global::ArgumentParsing.Results.ParseResultState.ParsedSpecialCommand:", identDelta: -1);
                writer.WriteLine("int exitCode = result.SpecialCommandHandler.HandleCommand();");
                writer.WriteLine("global::System.Environment.Exit(exitCode);");
                writer.WriteLine("break;");
            }
            writer.Ident--;
            writer.CloseRemainingBlocks();
            writer.WriteLine();
        }

        cancellationToken.ThrowIfCancellationRequested();

        var @namespace = hierarchy.Namespace;
        if (!string.IsNullOrEmpty(@namespace))
        {
            writer.WriteLine($"namespace {@namespace}");
            writer.OpenBlock();
        }

        foreach (var type in hierarchy.Hierarchy)
        {
            writer.WriteLine($"partial {type.GetTypeKeyword()} {type.QualifiedName}");
            writer.OpenBlock();
        }

        writer.WriteLine(generatedCodeAttribute);
        writer.WriteLine(ExcludeFromCodeCoverageAttribute);
        writer.WriteLine($"{method.Modifiers} {method.ReturnType} {method.Name}({method.ArgsParameterInfo.Type} {method.ArgsParameterInfo.Name})");
        writer.OpenBlock();

        foreach (var info in optionInfos)
        {
            var baseType = info.BaseType;
            var baseTypeWithNullabilityMark = info.IsNullable ? $"{info.BaseType}?" : info.BaseType;

            writer.WriteLine(info.SequenceType switch
            {
                SequenceType.None => $"{baseTypeWithNullabilityMark} {info.PropertyName}_val = default({baseTypeWithNullabilityMark});",
                SequenceType.List => $"global::System.Collections.Generic.List<{baseType}> {info.PropertyName}_builder = new();",
                SequenceType.ImmutableArray => $"global::System.Collections.Immutable.ImmutableArray<{baseType}>.Builder {info.PropertyName}_builder = global::System.Collections.Immutable.ImmutableArray.CreateBuilder<{baseType}>();",
                _ => throw new InvalidOperationException("Unreachable"),
            });
        }

        foreach (var info in parameterInfos)
        {
            var baseType = info.BaseType;
            var baseTypeWithNullabilityMark = info.IsNullable ? $"{baseType}?" : baseType;
            writer.WriteLine($"{baseTypeWithNullabilityMark} {info.PropertyName}_val = default({baseTypeWithNullabilityMark});");
        }

        if (remainingParametersInfo is not null)
        {
            var baseType = remainingParametersInfo.BaseType;

            writer.WriteLine(remainingParametersInfo.SequenceType switch
            {
                SequenceType.List => $"global::System.Collections.Generic.List<{baseType}>.Builder remainingParametersBuilder = new();",
                SequenceType.ImmutableArray => $"global::System.Collections.Immutable.ImmutableArray<{baseType}>.Builder remainingParametersBuilder = global::System.Collections.Immutable.ImmutableArray.CreateBuilder<{baseType}>();",
                _ => throw new InvalidOperationException("Unreachable"),
            });
        }

        cancellationToken.ThrowIfCancellationRequested();

        var hasAnyOptions = optionInfos.Length > 0;
        var hasAnyParameters = parameterInfos.Length > 0;

        writer.WriteLine();
        writer.WriteLine($"int state = {(hasAnySpecialCommandHandlers ? "-3" : "0")};");
        if (hasAnyOptions)
        {
            writer.WriteLine("int seenOptions = 0;");
        }
        writer.WriteLine("global::System.Collections.Generic.HashSet<global::ArgumentParsing.Results.Errors.ParseError> errors = null;");
        if (canUseOptimalSpanBasedAlgorithm)
        {
            writer.WriteLine("global::System.Span<global::System.Range> longArgSplit = stackalloc global::System.Range[2];");
        }
        var spanOrString = canUseOptimalSpanBasedAlgorithm ? "global::System.ReadOnlySpan<char>" : "string";
        writer.WriteLine($"{spanOrString} latestOptionName = default({spanOrString});");
        if (hasAnyOptions)
        {
            writer.WriteLine("string previousArgument = null;");
        }
        var hasSequenceOptions = optionInfos.Any(static i => i.SequenceType != SequenceType.None);
        if (hasSequenceOptions)
        {
            writer.WriteLine("int optionSource = 0;");
        }
        if (hasAnyParameters)
        {
            writer.WriteLine("int parameterIndex = 0;");
        }
        writer.WriteLine();

        writer.WriteLine($"foreach (string arg in {method.ArgsParameterInfo.Name})");
        writer.OpenBlock();
        if (hasAnySpecialCommandHandlers)
        {
            writer.WriteLine("if (state == -3)");
            writer.OpenBlock();
            writer.WriteLine("switch (arg)");
            writer.OpenBlock();
            if (hasBuiltInHelp)
            {
                writer.WriteLine("case \"--help\":");
                writer.Ident++;
                writer.WriteLine($"return new {method.ReturnType}(new global::ArgumentParsing.Generated.HelpCommandHandler_{qualifiedName.Replace('.', '_')}());");
                writer.Ident--;
            }
            if (hasBuiltInVersion)
            {
                writer.WriteLine("case \"--version\":");
                writer.Ident++;
                writer.WriteLine($"return new {method.ReturnType}(new global::ArgumentParsing.Generated.VersionCommandHandler());");
                writer.Ident--;
            }
            foreach (var commandHandler in additionalCommandHandlers)
            {
                foreach (var alias in commandHandler.Aliases)
                {
                    writer.WriteLine($"case \"{alias}\":");
                }
                writer.Ident++;
                writer.WriteLine($"return new {method.ReturnType}(new {commandHandler.Type}());");
                writer.Ident--;
            }
            writer.CloseBlock();
            writer.WriteLine();
            writer.WriteLine("state = 0;");
            writer.CloseBlock();
            writer.WriteLine();
        }
        writer.WriteLine($"{spanOrString} val;");
        writer.WriteLine();
        writer.WriteLine("bool hasLetters = global::System.Linq.Enumerable.Any(arg, char.IsLetter);");
        writer.WriteLine($"bool startsOption = hasLetters && arg.Length > 1 && {(hasStringStartsWithCharOverload ? "arg.StartsWith('-')" : "(arg[0] == '-')")};");
        writer.WriteLine();
        if (hasAnyOptions)
        {
            writer.WriteLine("if (state > 0 && startsOption)");
            writer.OpenBlock();
            writer.WriteLine("errors ??= new();");
            writer.Write("errors.Add(new global::ArgumentParsing.Results.Errors.OptionValueIsNotProvidedError(");
            if (errorMessageFormatProvider is not null)
            {
                writer.Write($"{errorMessageFormatProvider}.OptionValueIsNotProvidedError, ");
            }
            writer.WriteLine("previousArgument));");
            writer.WriteLine("state = 0;");
            writer.CloseBlock();
            writer.WriteLine();
        }
        writer.WriteLine("if (state != -2)");
        writer.OpenBlock();
        writer.WriteLine("if (arg.StartsWith(\"--\") && (hasLetters || arg.Length == 2 || arg.Contains('=')))");
        writer.OpenBlock();
        writer.WriteLine($"{spanOrString} slice = {(canUseOptimalSpanBasedAlgorithm ? "global::System.MemoryExtensions.AsSpan(arg, 2)" : "arg.Substring(2)")};");
        if (canUseOptimalSpanBasedAlgorithm)
        {
            writer.WriteLine("int written = global::System.MemoryExtensions.Split(slice, longArgSplit, '=');");
        }
        else
        {
            writer.WriteLine("string[] split = slice.Split(new char[] { '=' }, count: 2);");
            writer.WriteLine("int written = split.Length;");
        }
        writer.WriteLine();
        if (hasSequenceOptions)
        {
            writer.WriteLine("optionSource = 2;");
            writer.WriteLine();
        }
        writer.WriteLine($"latestOptionName = {(canUseOptimalSpanBasedAlgorithm ? "slice[longArgSplit[0]]" : "split[0]")};");
        writer.WriteLine("switch (latestOptionName)");
        writer.OpenBlock();

        cancellationToken.ThrowIfCancellationRequested();

        writer.WriteLine("case \"\":");
        writer.Ident++;
        writer.WriteLine("if (written == 1)");
        writer.OpenBlock();
        writer.WriteLine("state = -2;");
        writer.CloseBlock();
        writer.WriteLine("else");
        writer.OpenBlock();
        writer.WriteLine("errors ??= new();");
        writer.Write("errors.Add(new global::ArgumentParsing.Results.Errors.UnrecognizedArgumentError(");
        if (errorMessageFormatProvider is not null)
        {
            writer.Write($"{errorMessageFormatProvider}.UnrecognizedArgumentError, ");
        }
        writer.WriteLine("arg));");
        writer.CloseBlock();
        writer.WriteLine("continue;");
        writer.Ident--;

        Span<char> usageCode = stackalloc char[optionInfos.Length];

        for (var i = 0; i < optionInfos.Length; i++)
        {
            var info = optionInfos[i];

            if (info.LongName is null)
            {
                continue;
            }

            writer.WriteLine($"case \"{info.LongName}\":");
            writer.Ident++;
            usageCode.Fill('0');
            usageCode[^(i + 1)] = '1';
            writer.WriteLine($"if ((seenOptions & 0b{usageCode.ToString()}) > 0)");
            writer.OpenBlock();
            writer.WriteLine("errors ??= new();");
            writer.Write("errors.Add(new global::ArgumentParsing.Results.Errors.DuplicateOptionError(");
            if (errorMessageFormatProvider is not null)
            {
                writer.Write($"{errorMessageFormatProvider}.DuplicateOptionError, ");
            }
            writer.WriteLine($"\"{info.LongName}\"));");
            writer.CloseBlock();
            if (info.ParseStrategy == ParseStrategy.Flag)
            {
                writer.WriteLine($"{info.PropertyName}_val = true;");
                writer.WriteLine($"state = {(!info.IsNullable ? "-10" : (int.MinValue + i))};");
            }
            else
            {
                writer.WriteLine($"state = {(info.SequenceType != SequenceType.None ? (int.MinValue + i) : i + 1)};");
            }
            writer.WriteLine($"seenOptions |= 0b{usageCode.ToString()};");
            writer.WriteLine("break;");
            writer.Ident--;
        }

        writer.WriteLine("default:");
        writer.Ident++;
        writer.WriteLine("errors ??= new();");
        writer.Write("errors.Add(new global::ArgumentParsing.Results.Errors.UnknownOptionError(");
        if (errorMessageFormatProvider is not null)
        {
            writer.Write($"{errorMessageFormatProvider}.UnknownOptionError, ");
        }
        writer.WriteLine($"latestOptionName{(canUseOptimalSpanBasedAlgorithm ? ".ToString()" : string.Empty)}, arg));");
        writer.WriteLine("if (written == 1)");
        writer.OpenBlock();
        writer.WriteLine("state = -1;");
        writer.CloseBlock();
        writer.WriteLine("goto continueMainLoop;");
        writer.Ident--;

        writer.CloseBlock();

        writer.WriteLine();
        writer.WriteLine("if (written == 2)");
        writer.OpenBlock();
        writer.WriteLine($"val = {(canUseOptimalSpanBasedAlgorithm ? "slice[longArgSplit[1]]" : "split[1]")};");
        writer.WriteLine("goto decodeValue;");
        writer.CloseBlock();
        writer.WriteLine();
        writer.WriteLine("goto continueMainLoop;");
        writer.CloseBlock();

        writer.WriteLine();
        writer.WriteLine("if (startsOption)");
        writer.OpenBlock();
        writer.WriteLine($"{spanOrString} slice = {(canUseOptimalSpanBasedAlgorithm ? "global::System.MemoryExtensions.AsSpan(arg, 1)" : "arg.Substring(1)")};");
        writer.WriteLine();
        if (hasSequenceOptions)
        {
            writer.WriteLine("optionSource = 1;");
            writer.WriteLine();
        }
        writer.WriteLine("for (int i = 0; i < slice.Length; i++)");
        writer.OpenBlock();
        writer.WriteLine("if (state > 0)");
        writer.OpenBlock();
        writer.WriteLine($"val = slice.{(canUseOptimalSpanBasedAlgorithm ? "Slice" : "Substring")}(i);");
        writer.WriteLine("goto decodeValue;");
        writer.CloseBlock();
        writer.WriteLine();
        writer.WriteLine("char shortOptionName = slice[i];");
        writer.WriteLine($"latestOptionName = {(canUseOptimalSpanBasedAlgorithm ? "new global::System.ReadOnlySpan<char>(in slice[i])" : "shortOptionName.ToString()")};");
        writer.WriteLine("switch (shortOptionName)");
        writer.OpenBlock();

        cancellationToken.ThrowIfCancellationRequested();

        for (var i = 0; i < optionInfos.Length; i++)
        {
            var info = optionInfos[i];
            Debug.Assert(info.ParseStrategy != ParseStrategy.None);

            if (!info.ShortName.HasValue)
            {
                continue;
            }

            writer.WriteLine($"case '{info.ShortName}':");
            writer.Ident++;
            usageCode.Fill('0');
            usageCode[^(i + 1)] = '1';
            writer.WriteLine($"if ((seenOptions & 0b{usageCode.ToString()}) > 0)");
            writer.OpenBlock();
            writer.WriteLine("errors ??= new();");
            writer.Write("errors.Add(new global::ArgumentParsing.Results.Errors.DuplicateOptionError(");
            if (errorMessageFormatProvider is not null)
            {
                writer.Write($"{errorMessageFormatProvider}.DuplicateOptionError, ");
            }
            writer.WriteLine($"\"{info.ShortName}\"));");
            writer.CloseBlock();
            if (info.ParseStrategy == ParseStrategy.Flag)
            {
                writer.WriteLine($"{info.PropertyName}_val = true;");
                writer.WriteLine($"state = {(!info.IsNullable ? "-10" : (int.MinValue + i))};");
            }
            else
            {
                writer.WriteLine($"state = {(info.SequenceType != SequenceType.None ? (int.MinValue + i) : i + 1)};");
            }
            writer.WriteLine($"seenOptions |= 0b{usageCode.ToString()};");
            writer.WriteLine("break;");
            writer.Ident--;
        }

        writer.WriteLine("default:");
        writer.Ident++;
        if (optionInfos.Any(static i => i.ParseStrategy == ParseStrategy.Flag || i.SequenceType != SequenceType.None))
        {
            writer.WriteLine($"if (state <= -10)");
            writer.OpenBlock();
            writer.WriteLine($"val = slice.{(canUseOptimalSpanBasedAlgorithm ? "Slice" : "Substring")}(i);");
            writer.WriteLine($"latestOptionName = {(canUseOptimalSpanBasedAlgorithm ? "new global::System.ReadOnlySpan<char>(in slice[i - 1])" : "slice[i - 1].ToString()")};");
            writer.WriteLine("goto decodeValue;");
            writer.CloseBlock();
        }
        writer.WriteLine("errors ??= new();");
        writer.Write("errors.Add(new global::ArgumentParsing.Results.Errors.UnknownOptionError(");
        if (errorMessageFormatProvider is not null)
        {
            writer.Write($"{errorMessageFormatProvider}.UnknownOptionError, ");
        }
        writer.WriteLine("shortOptionName.ToString(), arg));");
        writer.WriteLine("state = -1;");
        writer.WriteLine("goto continueMainLoop;");
        writer.Ident--;

        writer.CloseBlock();
        writer.CloseBlock();
        writer.WriteLine();
        writer.WriteLine("goto continueMainLoop;");
        writer.CloseBlock();
        writer.CloseBlock();

        writer.WriteLine();
        writer.WriteLine($"val = {(canUseOptimalSpanBasedAlgorithm ? "global::System.MemoryExtensions.AsSpan(arg)" : "arg")};");
        if (hasSequenceOptions)
        {
            writer.WriteLine("optionSource = 0;");
        }
        writer.WriteLine();

        writer.WriteLine("decodeValue:", identDelta: -1);
        writer.WriteLine("switch (state)");
        writer.OpenBlock();
        if (!hasAnyParameters && optionInfos.Any(static i => i is { ParseStrategy: ParseStrategy.Flag, IsNullable: false }))
        {
            writer.WriteLine("case -10:");
            writer.Ident++;
            writer.WriteLine("errors ??= new();");
            writer.Write("errors.Add(new global::ArgumentParsing.Results.Errors.FlagOptionValueError(");
            if (errorMessageFormatProvider is not null)
            {
                writer.Write($"{errorMessageFormatProvider}.FlagOptionValueError, ");
            }
            writer.WriteLine($"latestOptionName{(canUseOptimalSpanBasedAlgorithm ? ".ToString()" : string.Empty)}));");
            writer.WriteLine("break;");
            writer.Ident--;
        }
        writer.WriteLine("case -1:");
        writer.Ident++;
        writer.WriteLine("break;");
        writer.Ident--;

        cancellationToken.ThrowIfCancellationRequested();

        for (var i = 0; i < optionInfos.Length; i++)
        {
            var info = optionInfos[i];

            var propertyName = info.PropertyName;
            var parseStrategy = info.ParseStrategy;
            var baseType = info.BaseType;
            var isNullable = info.IsNullable;
            var sequenceType = info.SequenceType;

            if (parseStrategy == ParseStrategy.Flag && !isNullable)
            {
                continue;
            }

            writer.WriteLine($"case {(parseStrategy == ParseStrategy.Flag || sequenceType != SequenceType.None ? (int.MinValue + i) : (i + 1))}:");
            writer.Ident++;
            if (sequenceType != SequenceType.None)
            {
                writer.WriteLine($"{baseType} {propertyName}_val = default({baseType});");
            }
            switch (parseStrategy)
            {
                case ParseStrategy.String:
                    writer.WriteLine($"{propertyName}_val = val{(canUseOptimalSpanBasedAlgorithm ? ".ToString()" : string.Empty)};");
                    break;
                case ParseStrategy.Integer:
                case ParseStrategy.Float:
                    if (isNullable)
                    {
                        writer.WriteLine($"{baseType} {propertyName}_underlying = default({baseType});");
                    }
                    var numberStyles = parseStrategy == ParseStrategy.Integer ? "global::System.Globalization.NumberStyles.Integer" : "global::System.Globalization.NumberStyles.Float | global::System.Globalization.NumberStyles.AllowThousands";
                    writer.WriteLine($"if (!{baseType}.TryParse(val, {numberStyles}, global::System.Globalization.CultureInfo.InvariantCulture, out {propertyName}{(isNullable ? "_underlying" : "_val")}))");
                    writer.OpenBlock();
                    writer.WriteLine("errors ??= new();");
                    writer.Write("errors.Add(new global::ArgumentParsing.Results.Errors.BadOptionValueFormatError(");
                    if (errorMessageFormatProvider is not null)
                    {
                        writer.Write($"{errorMessageFormatProvider}.BadOptionValueFormatError, ");
                    }
                    writer.WriteLine($"val{(canUseOptimalSpanBasedAlgorithm ? ".ToString()" : string.Empty)}, latestOptionName{(canUseOptimalSpanBasedAlgorithm ? ".ToString()" : string.Empty)}));");
                    writer.CloseBlock();
                    if (isNullable)
                    {
                        writer.WriteLine($"{propertyName}_val = {propertyName}_underlying;");
                    }
                    break;
                case ParseStrategy.Flag when isNullable:
                    writer.WriteLine($"bool {propertyName}_underlying = default({baseType});");
                    writer.WriteLine($"if (!bool.TryParse(val, out {propertyName}_underlying))");
                    writer.OpenBlock();
                    writer.WriteLine("errors ??= new();");
                    writer.Write("errors.Add(new global::ArgumentParsing.Results.Errors.BadOptionValueFormatError(");
                    if (errorMessageFormatProvider is not null)
                    {
                        writer.Write($"{errorMessageFormatProvider}.BadOptionValueFormatError, ");
                    }
                    writer.WriteLine($"val{(canUseOptimalSpanBasedAlgorithm ? ".ToString()" : string.Empty)}, latestOptionName{(canUseOptimalSpanBasedAlgorithm ? ".ToString()" : string.Empty)}));");
                    writer.CloseBlock();
                    writer.WriteLine($"{propertyName}_val = {propertyName}_underlying;");
                    break;
                case ParseStrategy.Enum:
                    if (isNullable)
                    {
                        writer.WriteLine($"{baseType} {propertyName}_underlying = default({baseType});");
                    }
                    writer.WriteLine($"if (!global::System.Enum.TryParse<{baseType}>(val, out {propertyName}{(isNullable ? "_underlying" : "_val")}))");
                    writer.OpenBlock();
                    writer.WriteLine("errors ??= new();");
                    writer.Write("errors.Add(new global::ArgumentParsing.Results.Errors.BadOptionValueFormatError(");
                    if (errorMessageFormatProvider is not null)
                    {
                        writer.Write($"{errorMessageFormatProvider}.BadOptionValueFormatError, ");
                    }
                    writer.WriteLine($"val{(canUseOptimalSpanBasedAlgorithm ? ".ToString()" : string.Empty)}, latestOptionName{(canUseOptimalSpanBasedAlgorithm ? ".ToString()" : string.Empty)}));");
                    writer.CloseBlock();
                    if (isNullable)
                    {
                        writer.WriteLine($"{propertyName}_val = {propertyName}_underlying;");
                    }
                    break;
                case ParseStrategy.Char:
                    writer.WriteLine($"if (val.Length == 1)");
                    writer.OpenBlock();
                    writer.WriteLine($"{propertyName}_val = val[0];");
                    writer.CloseBlock();
                    writer.WriteLine("else");
                    writer.OpenBlock();
                    writer.WriteLine("errors ??= new();");
                    writer.Write($"errors.Add(new global::ArgumentParsing.Results.Errors.BadOptionValueFormatError(");
                    if (errorMessageFormatProvider is not null)
                    {
                        writer.Write($"{errorMessageFormatProvider}.BadOptionValueFormatError, ");
                    }
                    writer.WriteLine($"val{(canUseOptimalSpanBasedAlgorithm ? ".ToString()" : string.Empty)}, latestOptionName{(canUseOptimalSpanBasedAlgorithm ? ".ToString()" : string.Empty)}));");
                    writer.CloseBlock();
                    break;
                case ParseStrategy.DateTimeRelated:
                    if (isNullable)
                    {
                        writer.WriteLine($"{baseType} {propertyName}_underlying = default({baseType});");
                    }
                    writer.WriteLine($"if (!{baseType}.TryParse(val, global::System.Globalization.CultureInfo.InvariantCulture, global::System.Globalization.DateTimeStyles.None, out {propertyName}{(isNullable ? "_underlying" : "_val")}))");
                    writer.OpenBlock();
                    writer.WriteLine("errors ??= new();");
                    writer.Write("errors.Add(new global::ArgumentParsing.Results.Errors.BadOptionValueFormatError(");
                    if (errorMessageFormatProvider is not null)
                    {
                        writer.Write($"{errorMessageFormatProvider}.BadOptionValueFormatError, ");
                    }
                    writer.WriteLine($"val{(canUseOptimalSpanBasedAlgorithm ? ".ToString()" : string.Empty)}, latestOptionName{(canUseOptimalSpanBasedAlgorithm ? ".ToString()" : string.Empty)}));");
                    writer.CloseBlock();
                    if (isNullable)
                    {
                        writer.WriteLine($"{propertyName}_val = {propertyName}_underlying;");
                    }
                    break;
                case ParseStrategy.TimeSpan:
                case ParseStrategy.GenericSpanParsable:
                case ParseStrategy.GenericParsable:
                    if (isNullable)
                    {
                        writer.WriteLine($"{baseType} {propertyName}_underlying = default({baseType});");
                    }
                    writer.WriteLine($"if (!{baseType}.TryParse(val{(canUseOptimalSpanBasedAlgorithm && parseStrategy == ParseStrategy.GenericParsable ? ".ToString()" : string.Empty)}, global::System.Globalization.CultureInfo.InvariantCulture, out {propertyName}{(isNullable ? "_underlying" : "_val")}))");
                    writer.OpenBlock();
                    writer.WriteLine("errors ??= new();");
                    writer.Write("errors.Add(new global::ArgumentParsing.Results.Errors.BadOptionValueFormatError(");
                    if (errorMessageFormatProvider is not null)
                    {
                        writer.Write($"{errorMessageFormatProvider}.BadOptionValueFormatError, ");
                    }
                    writer.WriteLine($"val{(canUseOptimalSpanBasedAlgorithm ? ".ToString()" : string.Empty)}, latestOptionName{(canUseOptimalSpanBasedAlgorithm ? ".ToString()" : string.Empty)}));");
                    writer.CloseBlock();
                    if (isNullable)
                    {
                        writer.WriteLine($"{propertyName}_val = {propertyName}_underlying;");
                    }
                    break;
            }
            if (sequenceType != SequenceType.None)
            {
                writer.WriteLine($"{propertyName}_builder.Add({propertyName}_val);");
                writer.WriteLine("if (optionSource > 0)");
                writer.OpenBlock();
                writer.WriteLine("state = 0;");
                writer.CloseBlock();
                writer.WriteLine("continue;");
            }
            else
            {
                writer.WriteLine("break;");
            }
            writer.Ident--;
        }

        writer.WriteLine("default:");
        writer.Ident++;
        if (hasAnyParameters)
        {
            writer.WriteLine("switch (parameterIndex++)");
            writer.OpenBlock();
            for (var i = 0; i < parameterInfos.Length; i++)
            {
                var info = parameterInfos[i];
                var propertyName = info.PropertyName;
                var parseStrategy = info.ParseStrategy;
                Debug.Assert(parseStrategy != ParseStrategy.None);
                var baseType = info.BaseType;
                var isNullable = info.IsNullable;

                writer.WriteLine($"case {i}:");
                writer.Ident++;
                switch (parseStrategy)
                {
                    case ParseStrategy.String:
                        writer.WriteLine($"{propertyName}_val = arg;");
                        break;
                    case ParseStrategy.Integer:
                    case ParseStrategy.Float:
                        if (isNullable)
                        {
                            writer.WriteLine($"{baseType} {propertyName}_underlying = default({baseType});");
                        }
                        var numberStyles = parseStrategy == ParseStrategy.Integer ? "global::System.Globalization.NumberStyles.Integer" : "global::System.Globalization.NumberStyles.Float | global::System.Globalization.NumberStyles.AllowThousands";
                        writer.WriteLine($"if (!{baseType}.TryParse(val, {numberStyles}, global::System.Globalization.CultureInfo.InvariantCulture, out {propertyName}{(isNullable ? "_underlying" : "_val")}))");
                        writer.OpenBlock();
                        writer.WriteLine("errors ??= new();");
                        writer.Write($"errors.Add(new global::ArgumentParsing.Results.Errors.BadParameterValueFormatError(");
                        if (errorMessageFormatProvider is not null)
                        {
                            writer.Write($"{errorMessageFormatProvider}.BadParameterValueFormatError, ");
                        }
                        writer.WriteLine($"arg, \"{info.Name}\", parameterIndex - 1));");
                        writer.CloseBlock();
                        if (isNullable)
                        {
                            writer.WriteLine($"{propertyName}_val = {propertyName}_underlying;");
                        }
                        break;
                    case ParseStrategy.Flag:
                        if (isNullable)
                        {
                            writer.WriteLine($"{baseType} {propertyName}_underlying = default({baseType});");
                        }
                        writer.WriteLine($"if (!bool.TryParse(arg, out {propertyName}{(isNullable ? "_underlying" : "_val")}))");
                        writer.OpenBlock();
                        writer.WriteLine("errors ??= new();");
                        writer.Write($"errors.Add(new global::ArgumentParsing.Results.Errors.BadParameterValueFormatError(");
                        if (errorMessageFormatProvider is not null)
                        {
                            writer.Write($"{errorMessageFormatProvider}.BadParameterValueFormatError, ");
                        }
                        writer.WriteLine($"arg, \"{info.Name}\", parameterIndex - 1));");
                        writer.CloseBlock();
                        if (isNullable)
                        {
                            writer.WriteLine($"{propertyName}_val = {propertyName}_underlying;");
                        }
                        break;
                    case ParseStrategy.Enum:
                        if (isNullable)
                        {
                            writer.WriteLine($"{baseType} {propertyName}_underlying = default({baseType});");
                        }
                        writer.WriteLine($"if (!global::System.Enum.TryParse<{baseType}>(arg, out {propertyName}{(isNullable ? "_underlying" : "_val")}))");
                        writer.OpenBlock();
                        writer.WriteLine("errors ??= new();");
                        writer.Write($"errors.Add(new global::ArgumentParsing.Results.Errors.BadParameterValueFormatError(");
                        if (errorMessageFormatProvider is not null)
                        {
                            writer.Write($"{errorMessageFormatProvider}.BadParameterValueFormatError, ");
                        }
                        writer.WriteLine($"arg, \"{info.Name}\", parameterIndex - 1));");
                        writer.CloseBlock();
                        if (isNullable)
                        {
                            writer.WriteLine($"{propertyName}_val = {propertyName}_underlying;");
                        }
                        break;
                    case ParseStrategy.Char:
                        writer.WriteLine($"if (arg.Length == 1)");
                        writer.OpenBlock();
                        writer.WriteLine($"{propertyName}_val = arg[0];");
                        writer.CloseBlock();
                        writer.WriteLine("else");
                        writer.OpenBlock();
                        writer.WriteLine("errors ??= new();");
                        writer.Write($"errors.Add(new global::ArgumentParsing.Results.Errors.BadParameterValueFormatError(");
                        if (errorMessageFormatProvider is not null)
                        {
                            writer.Write($"{errorMessageFormatProvider}.BadParameterValueFormatError, ");
                        }
                        writer.WriteLine($"arg, \"{info.Name}\", parameterIndex - 1));");
                        writer.CloseBlock();
                        break;
                    case ParseStrategy.DateTimeRelated:
                        if (isNullable)
                        {
                            writer.WriteLine($"{baseType} {propertyName}_underlying = default({baseType});");
                        }
                        writer.WriteLine($"if (!{baseType}.TryParse(val, global::System.Globalization.CultureInfo.InvariantCulture, global::System.Globalization.DateTimeStyles.None, out {propertyName}{(isNullable ? "_underlying" : "_val")}))");
                        writer.OpenBlock();
                        writer.WriteLine("errors ??= new();");
                        writer.Write($"errors.Add(new global::ArgumentParsing.Results.Errors.BadParameterValueFormatError(");
                        if (errorMessageFormatProvider is not null)
                        {
                            writer.Write($"{errorMessageFormatProvider}.BadParameterValueFormatError, ");
                        }
                        writer.WriteLine($"arg, \"{info.Name}\", parameterIndex - 1));");
                        writer.CloseBlock();
                        if (isNullable)
                        {
                            writer.WriteLine($"{propertyName}_val = {propertyName}_underlying;");
                        }
                        break;
                    case ParseStrategy.TimeSpan:
                    case ParseStrategy.GenericSpanParsable:
                    case ParseStrategy.GenericParsable:
                        if (isNullable)
                        {
                            writer.WriteLine($"{baseType} {propertyName}_underlying = default({baseType});");
                        }
                        writer.WriteLine($"if (!{baseType}.TryParse(val{(canUseOptimalSpanBasedAlgorithm && parseStrategy == ParseStrategy.GenericParsable ? ".ToString()" : string.Empty)}, global::System.Globalization.CultureInfo.InvariantCulture, out {propertyName}{(isNullable ? "_underlying" : "_val")}))");
                        writer.OpenBlock();
                        writer.WriteLine("errors ??= new();");
                        writer.Write($"errors.Add(new global::ArgumentParsing.Results.Errors.BadParameterValueFormatError(");
                        if (errorMessageFormatProvider is not null)
                        {
                            writer.Write($"{errorMessageFormatProvider}.BadParameterValueFormatError, ");
                        }
                        writer.WriteLine($"arg, \"{info.Name}\", parameterIndex - 1));");
                        writer.CloseBlock();
                        if (isNullable)
                        {
                            writer.WriteLine($"{propertyName}_val = {propertyName}_underlying;");
                        }
                        break;
                }
                writer.WriteLine("break;");
                writer.Ident--;
            }
            writer.WriteLine("default:");
            writer.Ident++;
            if (remainingParametersInfo is null)
            {
                writer.WriteLine("errors ??= new();");

                if (optionInfos.Any(static i => i is { ParseStrategy: ParseStrategy.Flag, IsNullable: false }))
                {
                    writer.WriteLine("if (state == -10)");
                    writer.OpenBlock();
                    writer.Write("errors.Add(new global::ArgumentParsing.Results.Errors.FlagOptionValueError(");
                    if (errorMessageFormatProvider is not null)
                    {
                        writer.Write($"{errorMessageFormatProvider}.FlagOptionValueError, ");
                    }
                    writer.WriteLine($"latestOptionName{(canUseOptimalSpanBasedAlgorithm ? ".ToString()" : string.Empty)}));");
                    writer.CloseBlock();
                    writer.WriteLine("else");
                    writer.OpenBlock();
                    writer.Write("errors.Add(new global::ArgumentParsing.Results.Errors.UnrecognizedArgumentError(");
                    if (errorMessageFormatProvider is not null)
                    {
                        writer.Write($"{errorMessageFormatProvider}.UnrecognizedArgumentError, ");
                    }
                    writer.WriteLine("arg));");
                    writer.CloseBlock();
                }
                else
                {
                    writer.Write("errors.Add(new global::ArgumentParsing.Results.Errors.UnrecognizedArgumentError(");
                    if (errorMessageFormatProvider is not null)
                    {
                        writer.Write($"{errorMessageFormatProvider}.UnrecognizedArgumentError, ");
                    }
                    writer.WriteLine("arg));");
                }
            }
            else
            {
                var propertyName = remainingParametersInfo.PropertyName;
                var type = remainingParametersInfo.BaseType;
                var parseStrategy = remainingParametersInfo.ParseStrategy;
                Debug.Assert(parseStrategy != ParseStrategy.None);
                switch (parseStrategy)
                {
                    case ParseStrategy.String:
                        writer.WriteLine("remainingParametersBuilder.Add(arg);");
                        break;
                    case ParseStrategy.Integer:
                    case ParseStrategy.Float:
                        writer.WriteLine($"{type} {propertyName}_val = default({type});");
                        var numberStyles = parseStrategy == ParseStrategy.Integer ? "global::System.Globalization.NumberStyles.Integer" : "global::System.Globalization.NumberStyles.Float | global::System.Globalization.NumberStyles.AllowThousands";
                        writer.WriteLine($"if (!{type}.TryParse(val, {numberStyles}, global::System.Globalization.CultureInfo.InvariantCulture, out {propertyName}_val))");
                        writer.OpenBlock();
                        writer.WriteLine("errors ??= new();");
                        writer.Write("errors.Add(new global::ArgumentParsing.Results.Errors.BadRemainingParameterValueFormatError(");
                        if (errorMessageFormatProvider is not null)
                        {
                            writer.Write($"{errorMessageFormatProvider}.BadRemainingParameterValueFormatError, ");
                        }
                        writer.WriteLine("arg, parameterIndex - 1));");
                        writer.CloseBlock();
                        writer.WriteLine($"remainingParametersBuilder.Add({propertyName}_val);");
                        break;
                    case ParseStrategy.Flag:
                        writer.WriteLine($"bool {propertyName}_val = default(bool);");
                        writer.WriteLine($"if (!bool.TryParse(arg, out {propertyName}_val))");
                        writer.OpenBlock();
                        writer.WriteLine("errors ??= new();");
                        writer.Write("errors.Add(new global::ArgumentParsing.Results.Errors.BadRemainingParameterValueFormatError(");
                        if (errorMessageFormatProvider is not null)
                        {
                            writer.Write($"{errorMessageFormatProvider}.BadRemainingParameterValueFormatError, ");
                        }
                        writer.WriteLine("arg, parameterIndex - 1));");
                        writer.CloseBlock();
                        writer.WriteLine($"remainingParametersBuilder.Add({propertyName}_val);");
                        break;
                    case ParseStrategy.Enum:
                        writer.WriteLine($"{type} {propertyName}_val = default({type});");
                        writer.WriteLine($"if (!global::System.Enum.TryParse<{type}>(arg, out {propertyName}_val))");
                        writer.OpenBlock();
                        writer.WriteLine("errors ??= new();");
                        writer.Write("errors.Add(new global::ArgumentParsing.Results.Errors.BadRemainingParameterValueFormatError(");
                        if (errorMessageFormatProvider is not null)
                        {
                            writer.Write($"{errorMessageFormatProvider}.BadRemainingParameterValueFormatError, ");
                        }
                        writer.WriteLine("arg, parameterIndex - 1));");
                        writer.CloseBlock();
                        writer.WriteLine($"remainingParametersBuilder.Add({propertyName}_val);");
                        break;
                    case ParseStrategy.Char:
                        writer.WriteLine($"if (arg.Length == 1)");
                        writer.OpenBlock();
                        writer.WriteLine($"remainingParametersBuilder.Add(arg[0]);");
                        writer.CloseBlock();
                        writer.WriteLine("else");
                        writer.OpenBlock();
                        writer.WriteLine("errors ??= new();");
                        writer.Write("errors.Add(new global::ArgumentParsing.Results.Errors.BadRemainingParameterValueFormatError(");
                        if (errorMessageFormatProvider is not null)
                        {
                            writer.Write($"{errorMessageFormatProvider}.BadRemainingParameterValueFormatError, ");
                        }
                        writer.WriteLine("arg, parameterIndex - 1));");
                        writer.CloseBlock();
                        break;
                    case ParseStrategy.DateTimeRelated:
                        writer.WriteLine($"{type} {propertyName}_val = default({type});");
                        writer.WriteLine($"if (!{type}.TryParse(arg, global::System.Globalization.CultureInfo.InvariantCulture, global::System.Globalization.DateTimeStyles.None, out {propertyName}_val))");
                        writer.OpenBlock();
                        writer.WriteLine("errors ??= new();");
                        writer.Write("errors.Add(new global::ArgumentParsing.Results.Errors.BadRemainingParameterValueFormatError(");
                        if (errorMessageFormatProvider is not null)
                        {
                            writer.Write($"{errorMessageFormatProvider}.BadRemainingParameterValueFormatError, ");
                        }
                        writer.WriteLine("arg, parameterIndex - 1));");
                        writer.CloseBlock();
                        writer.WriteLine($"remainingParametersBuilder.Add({propertyName}_val);");
                        break;
                    case ParseStrategy.TimeSpan:
                    case ParseStrategy.GenericSpanParsable:
                    case ParseStrategy.GenericParsable:
                        writer.WriteLine($"{type} {propertyName}_val = default({type});");
                        writer.WriteLine($"if (!{type}.TryParse(arg, global::System.Globalization.CultureInfo.InvariantCulture, out {propertyName}_val))");
                        writer.OpenBlock();
                        writer.WriteLine("errors ??= new();");
                        writer.Write("errors.Add(new global::ArgumentParsing.Results.Errors.BadRemainingParameterValueFormatError(");
                        if (errorMessageFormatProvider is not null)
                        {
                            writer.Write($"{errorMessageFormatProvider}.BadRemainingParameterValueFormatError, ");
                        }
                        writer.WriteLine("arg, parameterIndex - 1));");
                        writer.CloseBlock();
                        writer.WriteLine($"remainingParametersBuilder.Add({propertyName}_val);");
                        break;
                }
            }
            writer.WriteLine("break;");
            writer.Ident--;
            writer.CloseBlock();
        }
        else
        {
            writer.WriteLine("errors ??= new();");
            writer.Write("errors.Add(new global::ArgumentParsing.Results.Errors.UnrecognizedArgumentError(");
            if (errorMessageFormatProvider is not null)
            {
                writer.Write($"{errorMessageFormatProvider}.UnrecognizedArgumentError, ");
            }
            writer.WriteLine("arg));");
        }
        writer.WriteLine("break;");
        writer.Ident--;

        writer.CloseBlock();

        writer.WriteLine();
        writer.WriteLine("state = 0;");

        writer.WriteLine();
        writer.WriteLine("continueMainLoop:", identDelta: -1);
        if (hasAnyOptions)
        {
            writer.WriteLine("previousArgument = arg;");
        }
        else
        {
            writer.WriteLine(";");
        }
        writer.CloseBlock();

        if (hasAnyOptions)
        {
            writer.WriteLine();
            writer.WriteLine("if (state > 0)");
            writer.OpenBlock();
            writer.WriteLine("errors ??= new();");
            writer.Write("errors.Add(new global::ArgumentParsing.Results.Errors.OptionValueIsNotProvidedError(");
            if (errorMessageFormatProvider is not null)
            {
                writer.Write($"{errorMessageFormatProvider}.OptionValueIsNotProvidedError, ");
            }
            writer.WriteLine("previousArgument));");
            writer.CloseBlock();
        }

        for (var i = 0; i < optionInfos.Length; i++)
        {
            var info = optionInfos[i];

            if (info.IsRequired)
            {
                writer.WriteLine();
                usageCode.Fill('0');
                usageCode[^(i + 1)] = '1';
                writer.WriteLine($"if ((seenOptions & 0b{usageCode.ToString()}) == 0)");
                writer.OpenBlock();
                writer.WriteLine("errors ??= new();");
                writer.Write("errors.Add(new global::ArgumentParsing.Results.Errors.MissingRequiredOptionError(");
                writer.WriteLine((info.ShortName, info.LongName, errorMessageFormatProvider is null) switch
                {
                    (not null, null, true) => $"'{info.ShortName.Value}'));",
                    (null, not null, true) => $"\"{info.LongName}\"));",
                    (not null, not null, true) => $"'{info.ShortName.Value}', \"{info.LongName}\"));",
                    (not null, null, false) => $"{errorMessageFormatProvider}.MissingRequiredOptionError_OnlyShortOptionName, '{info.ShortName.Value}', null));",
                    (null, not null, false) => $"{errorMessageFormatProvider}.MissingRequiredOptionError_OnlyLongOptionName, null, \"{info.LongName}\"));",
                    (not null, not null, false) => $"{errorMessageFormatProvider}.MissingRequiredOptionError_BothOptionNames, '{info.ShortName.Value}', \"{info.LongName}\"));",
                    _ => throw new InvalidOperationException("Unreachable"),
                });
                writer.CloseBlock();
            }
        }

        for (var i = 0; i < parameterInfos.Length; i++)
        {
            var info = parameterInfos[i];

            if (info.IsRequired)
            {
                writer.WriteLine();
                writer.WriteLine($"if (parameterIndex <= {i})");
                writer.OpenBlock();
                writer.WriteLine("errors ??= new();");
                writer.WriteLine("errors.Add(new global::ArgumentParsing.Results.Errors.MissingRequiredParameterError(");
                if (errorMessageFormatProvider is not null)
                {
                    writer.Write($"{errorMessageFormatProvider}.MissingRequiredParameterError, ");
                }
                writer.WriteLine($"\"{info.Name}\", {i}));");
                writer.CloseBlock();
            }
        }

        writer.WriteLine();
        writer.WriteLine("if (errors != null)");
        writer.OpenBlock();
        writer.WriteLine($"return new {method.ReturnType}(global::ArgumentParsing.Results.Errors.ParseErrorCollection.AsErrorCollection(errors));");
        writer.CloseBlock();

        var optionsType = $"global::{qualifiedName}";
        writer.WriteLine();
        writer.WriteLine($"{optionsType} options = new {optionsType}");
        writer.OpenBlock();

        foreach (var info in optionInfos)
        {
            if (info.DefaultValueStrategy == DefaultValueStrategy.None)
            {
                writer.WriteLine($"{info.PropertyName} = {info.PropertyName}{(info.SequenceType != SequenceType.None ? "_builder" : "_val")}{(info.SequenceType == SequenceType.ImmutableArray ? ".ToImmutable()" : string.Empty)},");
            }
        }

        foreach (var info in parameterInfos)
        {
            writer.WriteLine($"{info.PropertyName} = {info.PropertyName}_val,");
        }

        if (remainingParametersInfo is not null)
        {
            writer.WriteLine($"{remainingParametersInfo.PropertyName} = {remainingParametersInfo.SequenceType switch
            {
                SequenceType.List => "remainingParametersBuilder",
                SequenceType.ImmutableArray => "remainingParametersBuilder.ToImmutable()",
                _ => throw new InvalidOperationException("Unreachable"),
            }},");
        }

        writer.Ident--;
        writer.WriteLine("};");
        writer.WriteLine();

        for (var i = 0; i < optionInfos.Length; i++)
        {
            var info = optionInfos[i];

            if (info.DefaultValueStrategy == DefaultValueStrategy.None)
            {
                continue;
            }

            usageCode.Fill('0');
            usageCode[^(i + 1)] = '1';
            writer.WriteLine($"if ((seenOptions & 0b{usageCode.ToString()}) > 0)");
            writer.OpenBlock();

            switch (info.DefaultValueStrategy)
            {
                case DefaultValueStrategy.Setter:
                    writer.WriteLine($"options.{info.PropertyName} = {info.PropertyName}{(info.SequenceType != SequenceType.None ? "_builder" : "_val")}{(info.SequenceType == SequenceType.ImmutableArray ? ".ToImmutable()" : string.Empty)};");
                    break;
                case DefaultValueStrategy.UnsafeAccessor:
                    writer.WriteLine($"Set{info.PropertyName}(options, {info.PropertyName}{(info.SequenceType != SequenceType.None ? "_builder" : "_val")}{(info.SequenceType == SequenceType.ImmutableArray ? ".ToImmutable()" : string.Empty)});");
                    break;
            }

            writer.CloseBlock();
            writer.WriteLine();
        }

        writer.WriteLine($"return new {method.ReturnType}(options);");

        if (optionInfos.Any(static i => i.DefaultValueStrategy == DefaultValueStrategy.UnsafeAccessor))
        {
            writer.WriteLine();

            foreach (var info in optionInfos)
            {
                if (info.DefaultValueStrategy != DefaultValueStrategy.UnsafeAccessor)
                {
                    continue;
                }

                writer.WriteLine($"[global::System.Runtime.CompilerServices.UnsafeAccessorAttribute(global::System.Runtime.CompilerServices.UnsafeAccessorKind.Method, Name = $\"set_{{nameof({optionsType}.{info.PropertyName})}}\")]");
                writer.WriteLine($"static extern void Set{info.PropertyName}({optionsType} @this, {info.SequenceType switch
                {
                    SequenceType.None => info.BaseType,
                    SequenceType.List => $"global::System.Collections.Generic.List<{info.BaseType}>",
                    SequenceType.ImmutableArray => $"global::System.Collections.Immutable.ImmutableArray<{info.BaseType}>",
                    _ => throw new InvalidOperationException("Unreachable"),
                }} value);");
            }
        }

        writer.CloseRemainingBlocks();

        context.AddSource($"{qualifiedName}.g.cs", writer.ToString().Trim());
    }

    private static void EmitHelpCommandHandler(SourceProductionContext context, ArgumentParserHelpInfo helpInfo)
    {
        var (optionsInfo, builtInCommandInfos, additionalCommandHandlers, assemblyVersionInfo) = helpInfo;
        var (qualifiedName, _, optionInfos, parameterInfos, remainingParametersInfo, helpTextGeneratorInfo) = optionsInfo;

        var writer = new CodeWriter();

        var generatorType = typeof(ArgumentParserGenerator);
        var generatedCodeAttribute = $"[global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"{generatorType.FullName}\", \"{generatorType.Assembly.GetName().Version}\")]";

        writer.WriteLine("// <auto-generated/>");
        writer.WriteLine("#nullable disable");
        writer.WriteLine("#pragma warning disable");
        writer.WriteLine();
        writer.WriteLine("namespace ArgumentParsing.Generated");
        writer.OpenBlock();
        writer.WriteLine("/// <summary>");
        writer.WriteLine($"/// Default implementation of <c>--help</c> command for <see cref=\"global::{qualifiedName}\"/> type");
        writer.WriteLine("/// </summary>");
        writer.WriteLine("[global::ArgumentParsing.SpecialCommands.SpecialCommandAliasesAttribute(\"--help\")]");
        writer.WriteLine(generatedCodeAttribute);
        writer.WriteLine(ExcludeFromCodeCoverageAttribute);
        writer.WriteLine($"internal sealed class HelpCommandHandler_{qualifiedName.Replace('.', '_')} : global::ArgumentParsing.SpecialCommands.ISpecialCommandHandler");
        writer.OpenBlock();
        if (helpTextGeneratorInfo is null)
        {
            writer.WriteLine("/// <summary>");
            writer.WriteLine($"/// Generates help text for <see cref=\"global::{qualifiedName}\"/> type.");
            writer.WriteLine("/// If <paramref name=\"errors\"/> parameter is supplied, generated text will contain an error section");
            writer.WriteLine("/// </summary>");
            writer.WriteLine("/// <param name=\"errors\">Parse errors to include into help text</param>");
            writer.WriteLine("/// <returns>Generated help text</returns>");
            writer.WriteLine("public static string GenerateHelpText(global::ArgumentParsing.Results.Errors.ParseErrorCollection? errors = null)");
            writer.OpenBlock();
            writer.WriteLine("global::System.Text.StringBuilder helpBuilder = new();");
            writer.WriteLine($"helpBuilder.AppendLine(\"{assemblyVersionInfo.Name} {assemblyVersionInfo.Version.ToString(3)}\");");
            writer.WriteLine("helpBuilder.AppendLine(\"Copyright (C) \" + global::System.DateTime.UtcNow.Year.ToString());");
            writer.WriteLine("if ((object)errors != null)");
            writer.OpenBlock();
            writer.WriteLine("helpBuilder.AppendLine();");
            writer.WriteLine("helpBuilder.AppendLine(\"ERROR(S):\");");
            writer.WriteLine("foreach (global::ArgumentParsing.Results.Errors.ParseError error in errors)");
            writer.OpenBlock();
            writer.WriteLine("helpBuilder.AppendLine(\"  \" + error.GetMessage());");
            writer.CloseBlock();
            writer.CloseBlock();
            if (optionInfos.Any())
            {
                writer.WriteLine("helpBuilder.AppendLine();");
                writer.WriteLine("helpBuilder.AppendLine(\"OPTIONS:\");");
                foreach (var info in optionInfos)
                {
                    writer.WriteLine("helpBuilder.AppendLine();");
                    writer.Write("helpBuilder.AppendLine(\"  ");
                    if (info.ShortName.HasValue)
                    {
                        writer.Write($"-{info.ShortName.Value}");
                    }
                    if (info.ShortName.HasValue && info.LongName is not null)
                    {
                        writer.Write(", ");
                    }
                    if (info.LongName is not null)
                    {
                        writer.Write($"--{info.LongName}");
                    }
                    var isRequired = info.IsRequired;
                    var helpDescription = info.HelpDescription;
                    if (isRequired || helpDescription is not null)
                    {
                        writer.Write("\\t");
                    }
                    if (isRequired)
                    {
                        writer.Write("Required");
                    }
                    if (helpDescription is not null)
                    {
                        if (isRequired)
                        {
                            writer.Write(". ");
                        }

                        writer.Write(helpDescription);
                    }
                    writer.WriteLine("\");");
                }
            }
            if (parameterInfos.Any())
            {
                writer.WriteLine("helpBuilder.AppendLine();");
                writer.WriteLine("helpBuilder.AppendLine(\"PARAMETERS:\");");
                for (var i = 0; i < parameterInfos.Length; i++)
                {
                    var info = parameterInfos[i];

                    writer.WriteLine("helpBuilder.AppendLine();");
                    writer.Write($"helpBuilder.AppendLine(\"  {info.Name} (at index {i})");
                    var isRequired = info.IsRequired;
                    var helpDescription = info.HelpDescription;
                    if (isRequired || helpDescription is not null)
                    {
                        writer.Write("\\t");
                    }
                    if (isRequired)
                    {
                        writer.Write("Required");
                    }
                    if (helpDescription is not null)
                    {
                        if (isRequired)
                        {
                            writer.Write(". ");
                        }

                        writer.Write(helpDescription);
                    }
                    writer.WriteLine("\");");
                }
            }
            if (remainingParametersInfo is not null)
            {
                writer.WriteLine("helpBuilder.AppendLine();");
                writer.Write("helpBuilder.AppendLine(\"  Remaining parameters");
                if (remainingParametersInfo.HelpDescription is not null)
                {
                    writer.Write($"\\t{remainingParametersInfo.HelpDescription}");
                }
                writer.WriteLine("\");");
            }

            var hasBuiltInHelp = builtInCommandInfos.Any(i => i.Handler == BuiltInCommandHandlers.Help);
            var hasBuiltInVersion = builtInCommandInfos.Any(i => i.Handler == BuiltInCommandHandlers.Version);

            if (hasBuiltInHelp ||
                hasBuiltInVersion ||
                !additionalCommandHandlers.IsEmpty)
            {
                writer.WriteLine("helpBuilder.AppendLine();");
                writer.WriteLine("helpBuilder.AppendLine(\"COMMANDS:\");");
                if (hasBuiltInHelp)
                {
                    writer.WriteLine("helpBuilder.AppendLine();");
                    var helpDescription = builtInCommandInfos.First(i => i.Handler == BuiltInCommandHandlers.Help).HelpDescription ?? "Show help screen";
                    writer.Write("helpBuilder.AppendLine(\"  --help");
                    if (helpDescription != string.Empty)
                    {
                        writer.Write($"\\t{helpDescription}");
                    }
                    writer.WriteLine("\");");
                }
                if (hasBuiltInVersion)
                {
                    writer.WriteLine("helpBuilder.AppendLine();");
                    var helpDescription = builtInCommandInfos.First(i => i.Handler == BuiltInCommandHandlers.Version).HelpDescription ?? "Show version information";
                    writer.Write("helpBuilder.AppendLine(\"  --version");
                    if (helpDescription != string.Empty)
                    {
                        writer.Write($"\\t{helpDescription}");
                    }
                    writer.WriteLine("\");");
                }
                foreach (var additionalHandler in additionalCommandHandlers)
                {
                    writer.WriteLine("helpBuilder.AppendLine();");
                    writer.Write($"helpBuilder.AppendLine(\"  {string.Join(", ", additionalHandler.Aliases)}");
                    if (additionalHandler.HelpDescription is { } helpDescription)
                    {
                        writer.WriteLine($"\\t{helpDescription}\");");
                    }
                    else
                    {
                        writer.WriteLine("\");");
                    }
                }
            }
            writer.WriteLine("return helpBuilder.ToString();");
            writer.CloseBlock();
            writer.WriteLine();
        }
        writer.WriteLine("/// <inheritdoc/>");
        writer.WriteLine("public int HandleCommand()");
        writer.OpenBlock();
        writer.WriteLine($"global::System.Console.Out.WriteLine({(helpTextGeneratorInfo is null ? "GenerateHelpText()" : $"{helpTextGeneratorInfo.TypeName}.{helpTextGeneratorInfo.MethodName}({helpTextGeneratorInfo.ParameterName}: null)")});");
        writer.WriteLine("return 0;");
        writer.CloseRemainingBlocks();

        context.AddSource($"HelpCommandHandler.{qualifiedName}.g.cs", writer.ToString().Trim());
    }

    private static void EmitVersionCommandHandler(SourceProductionContext context, (AssemblyVersionInfo, bool needsToGenerate) info)
    {
        var (versionInfo, needsToGenerate) = info;

        if (!needsToGenerate)
        {
            return;
        }

        var generatorType = typeof(ArgumentParserGenerator);
        var generatedCodeAttribute = $"[global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"{generatorType.FullName}\", \"{generatorType.Assembly.GetName().Version}\")]";

        var command = $$"""
            // <auto-generated/>
            #nullable disable
            #pragma warning disable

            namespace ArgumentParsing.Generated
            {
                /// <summary>
                /// Default implementation of <c>--version</c> command for <c>{{versionInfo.Name}}</c> assembly
                /// </summary>
                [global::ArgumentParsing.SpecialCommands.SpecialCommandAliasesAttribute("--version")]
                {{generatedCodeAttribute}}
                {{ExcludeFromCodeCoverageAttribute}}
                internal sealed class VersionCommandHandler : global::ArgumentParsing.SpecialCommands.ISpecialCommandHandler
                {
                    /// <inheritdoc/>
                    public int HandleCommand()
                    {
                        global::System.Console.WriteLine("{{versionInfo.Name}} {{versionInfo.Version.ToString(3)}}");
                        return 0;
                    }
                }
            }
            """;

        context.AddSource($"VersionCommandHandler.{versionInfo.Name}.g.cs", command);
    }
}
